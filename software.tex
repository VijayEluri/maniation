\section{Software preparation\label{softwarePreparation}}

\subsection{Data structures and file formats}
Two types of data files are mainly used in this project: an input file, specifying the bodies,
their geometry and initial configuration in a scene, and an output file for the simulation
results.

\subsubsection{Input data}
The input data has a graph structure which is visually represented in figure~XXX.
Geometric objects are represented as \emph{meshes} of triangles. Each triangle (or \emph{face})
of the object's surface is delimited by three \emph{vertices}. This simple structure is sufficient
to represent a great variety of shapes, and although a large number of vertices is necessary to
adequately approximate curved surfaces, the ease of handling this data outweighs the costs caused
by its quantity.

Several \emph{bodies} in the scene may share the same mesh if they are identical up to rotation
and translation. A mesh is also associated with a \emph{material} which is used to determine the
visual rendering (colour) and the physical behaviour (density, elasticity).

If the scene contains articulated bodies, \emph{skeletons} must be defined in the file. A skeleton
is a tree of \emph{bones} in which each bone has an offset and a rotation relative to its parent.
If one bone~-- say an upper arm~-- in this structure moves while all other relative rotations stay
unchanged, then all children of this bone~-- up to the tip of the little finger~-- will be rotated
equally. This matches the natural behaviour of a skeleton.

In an articulated mesh, each vertex is associated with one or more bones of a particular skeleton.
Normally it will be associated with one bone, but a weighted sum of two or even three adjacent
bones' transformations may be used to create the illusion of smoothly deforming joints. Hence it
is not possible to completely decompose an articulated body into its individual limbs, but the
articulated mesh must be treated as a whole.

Since this data structure is designed to be very general-purpose, I wanted to use a file format
which could easily be generated by 3D modelling applications or manually edited. I chose to use
\textsl{XML}\footnote{eXtensible Markup Language, \texttt{http://www.w3.org/XML/}} as a basis
since it is easy to read both by humans and by \textsl{XML} parsing libraries. I could not
find a format which suited my needs~-- all existing formats are either far too complicated or not
powerful enough~-- and therefore designed a custom schema. I also created an
\textsl{XSLT}\footnote{eXtensible Stylesheet Language with Transformations,
\texttt{http://www.w3.org/TR/xslt}} stylesheet which semi-automatically converts the
\textsl{Cal3D}\footnote{Character Animation Library file format, \texttt{http://cal3d.sourceforge.net/}}
format into input data for this project. \textsl{Cal3D} can be exported by \textsl{Blender}
(see below).

\subsubsection{Output data}
The output of a simulation is much simpler than the input data: All that is required is the
position and orientation, and possibly the velocities, of each body at each time step. For
articulated bodies, the orientation of each bone is also required. This suggests a simple
matrix layout in which bodies and bones are sorted along one dimension and time along
the other.

The output file is such a matrix, arranged in a simple \textsc{ascii} file format which can
directly be imported by \textsl{Octave} (see below). \textsl{Octave} can then be used for further
processing or evaluation of the results.

\subsection{Tools}
\subsubsection{Programming languages}
I chose \textsl{Java~1.5}\footnote{Using Sun's J2SE JDK~5.0, \texttt{http://java.sun.com/}}
as language for the implementation of the bulk of the project. Java's strictly object-oriented
paradigm and its package concept facilitate the management of large software engineering
projects; it is mature, well supported and benefits from an extensive run-time library. I
particularly appreciate its good type safety (and hence bug prevention) compared to languages
like C and make heavy use of the \emph{generic} type polymorphism added in version~1.5.

Java is a very verbose language though, so I decided that it would be beneficial to prototype
the algorithmically tricky parts in a concise scripting language first. For this I used
\textsl{GNU Octave}\footnote{GNU Octave~-- \texttt{http://www.octave.org/}~-- uses a language
mostly compatible to \textsc{Matlab}~-- \texttt{http://www.mathworks.com/products/matlab/}},
which is optimized for numerical matrix and vector-based computation. I implemented nearly all
numerical algorithms in this project in \textsl{Octave} first; this version was too slow to be
of much practical use, but was extremely useful to guide the subsequent Java implementation.

\subsubsection{Libraries}
Rendered output is specified in the project requirements, and the most common choice for
displaying 3D graphics in Java programs is the
\textsl{Java3D}\footnote{\texttt{https://java3d.dev.java.net/}} library. \textsl{Java3D} provides
a clean object-oriented interface to either a software renderer or accelerated graphics hardware,
and is also quite well documented.

Processing of the input file was done using an \textsl{XML data-binding tool} which I had
developed independently in summer 2005. This tool takes a grammar for an \textsl{XML} schema in
\textsl{RELAX NG}\footnote{\texttt{http://www.relaxng.org/}} format and generates a set of
Java classes for a run-time representation of that schema. The actual low-level parsing is done
by the \textsl{SAX}\footnote{Simple API for XML, \texttt{http://www.saxproject.org/}} parser
implementation in \textsl{Xerces}\footnote{Apache Xerces2 Java,
\texttt{http://xerces.apache.org/xerces2-j/}}.

Some of the numerical algorithms required by the simulation could have been obtained through
libraries. However, none of them are particularly complicated~-- their C implementation
in~\cite{NRinC} is at most a few pages long and is easy to translate into Java. I therefore chose
to implement the algorithms myself, giving me the freedom to incorporate enhancements like
equation~\ref{quergs}.

\subsubsection{Tool chain}

\textsl{Blender}, a 3D modelling application described below, supports internal scripting in
\textsl{Python}\footnote{\texttt{http://www.python.org/}}. In order to import simulated animations
into this application for checking and rendering I had to write some short \textsl{Python} scripts
as an interface.

\subsubsection{Input data}

