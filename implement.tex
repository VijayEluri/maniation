\section{Casting theory into code\label{implementation}}

Finally the theoretical preparation and design is completed. All the algorithms have been mapped
out~-- now they must be implemented and tested. This job was laborious but fairly straightforward
compared to the algorithmic design. My final implementation comprises 700 lines of \textsl{Octave}
code (prototyping and numerical tools) and 10500 lines of Java code for the main implementation
(including 3500 lines automatically generated by the XML data binding tool), plus a few fragments
in other languages.

\subsection{The engineering process}

The primary management challenge was to control the uncertainties caused by my lack of prior
knowledge of the algorithmic details required. The first four milestones, up to collision
detection, bore no major uncertainties, and could therefore be accomplished on schedule. I started
surveying the options for implementing articulated bodies during milestone~2; at this point I
realized that it was going to be much more challenging than expected, and that I would have to
adapt my strategy.

I decided to suspend coding after milestone~4 and to work on the theory until I was certain that
I understood it. If I tried to implement my ideas immediately, so I reckoned, the result would be
chaotic and a waste of time. I set myself a new hierarchy of tasks arranged in a rectangular grid.
From left to right, the columns were the simulation components as listed in
section~\ref{introOverview} (except for item~4, which was already completed). From top to bottom,
the rows were labelled
\begin{enumerate}
\item search for literature relevant to the subject;
\item read and completely understand it;
\item if it is insufficient and no more literature can be found, work out a new algorithm for
    doing it;
\item argue or prove that the algorithm works correctly;
\item write down a good explanation of the algorithm, as if it were for another person to read, to
    ensure I fully understand it;
\item write a prototype in Octave.
\end{enumerate}

The idea of this grid is that each cell~-- one of these six tasks applied to one of the five
simulation components~-- depends on those above and to the left of it. Thus I could start in the
top left-hand corner and work towards the bottom right-hand corner; backtracking was possible when
I got stuck, but still there was a clear objective and I could track progress. I decided that only
once I had covered the whole grid would I lay out and implement the Java program. Completing the
grid took me seven weeks, from mid-December until the end of January.

The Java implementation, testing and debugging were completed in the following seven weeks~-- due
to the thorough planning beforehand, this was slightly less than the nine weeks originally
allocated to this part of the project. Including the seven additional weeks required to complete
the ``theory grid'', the project was now five weeks behind schedule.

Writing the dissertation, again a task with few uncertainties, took the allotted length of time,
so the project also finished five weeks behind schedule. Given the very early completion date
originally envisaged, this still left enough time for exam revision.


\subsection{Application architecture}

The Java implementation consists of five packages:

\begin{description}
\item[Scene.] Facilities to load a scene description from an XML input file, and data structures
    to represent it at run-time. This package is automatically generated by the data binding tool.
\item[Maths.] General-purpose implementations of vectors, matrices (including sparse matrices),
    quaternions, solver for ordinary differential equations (variable-step-size Runge-Kutta with
    Cash-Karp parameters~\cite{NRinC}), and a solver for systems of linear equations (biconjugate
    gradient method, also taken from~\cite{NRinC}).
\item[Geometry.] Handling of triangle meshes at run-time: deformation of articulated meshes,
    rendering of meshes using Java3D, collision detection. (Depends on Scene and Maths)
\item[Dynamics.] Implementations of a rigid body and all the different constraint types.
    Architecture for handling interactions between objects. Articulated body code combining
    rigid bodies and constraints, and implementation of the collision/contact handling algorithms.
    (Depends on Scene, Maths and Geometry)
\item[Main.] Main application class and test cases. (Depends on Scene and Dynamics)
\end{description}

The application follows a clean object-oriented design throughout. Some excerpts from its
class/interface hierarchy are shown in figure~\ref{classHierarchy}. This diagram indicates how
extensible the architecture is: any two \textsf{SimulationObject}s can interact, generating an
\textsf{Interaction} object~-- this could be anything from a repulsive Coulomb force to some
sort of sentient behaviour~-- without having to change any of the rest of the system.

\begin{figure}
\centerline{\scalebox{0.4}{\includegraphics{figures/classes}}}
\caption{Two class inheritance hierarchies from the Dynamics package. Methods are omitted for
    better readability.\label{classHierarchy}}
\end{figure}

This design encapsulates algorithms in a way which is both clear and efficient. To give but two
examples:
\begin{itemize}
\item the ODE solver operates only on the \textsf{Vector} interface. The \textsf{RigidBody}'s
    state vector implements the \textsf{add} method in such a way that $\mathrm{Quergs}$ is
    automatically applied when appropriate. Thus the ODE solver needs to know nothing about
    $\mathrm{Quergs}$, and a \textsf{RigidBody} object can be handled by any ODE solver.
\item the biconjugate gradient method for solving linear equations only multiplies \textsf{Matrix}
    objects with \textsf{Vector}s. This operation is implemented efficiently for sparse matrices,
    so the algorithm can run quickly even though it knows nothing about sparsity itself.
\end{itemize}


\subsection{Making it work}

A flow chart of the overall program structure is given in figure~\ref{flowchart}, including
indicators to the constituent algorithms. I want to show how the various algorithms must be
combined, because it took me several attempts to get right despite careful thought beforehand.

\begin{figure}
\renewcommand{\baselinestretch}{1.3}\small\normalsize
\newcommand{\spx}{\vspace*{\baselineskip}\\}
\newcommand{\curly}[2]{\zerobox{b}{\mbox{$\left\}\:#1\begin{array}{l}#2\end{array}\right.$}}}
\begin{tabular}{|l|l|l|l|@{}l}
\multicolumn{5}{r}{explained in section $\downarrow$}\\\cline{1-4}
\multicolumn{4}{|l|}{Load scene and initial state from XML file}
&\curly{\ref{softwareTools}}{\spx}\hspace*{7mm}\\\cline{1-4}
\multicolumn{4}{|l|}{Compute initial set of interactions and constraints}&
\curly{\ref{meshIntersection}}{\spx}\\\cline{1-4}
\multicolumn{4}{|l|}{Choose initial time step length $h$}\\\cline{1-4}
\multicolumn{4}{|l|}{Repeat:}\\\cline{2-4}
    &\multicolumn{3}{|l|}{\texttt{Time step:}}\\\cline{2-4}
    &\multicolumn{3}{|l|}{For each time and state required by Runge-Kutta/Cash-Karp:}&
    \curly{\ref{solvingODEs}}{\spx}\\\cline{3-4}
        &&\multicolumn{2}{|l|}{Apply non-constraint forces (e.g.\ gravity)}\\\cline{3-4}
        &&\multicolumn{2}{|l|}{$\mbox{\textit{constraints}} = \mbox{\textit{equality constraints}}
        \cup \mbox{\textit{contact constraints}}$}\\\cline{3-4}
        &&\multicolumn{2}{|l|}{Repeat:}\\\cline{4-4}
            &&&Solve \textit{constraints} for Lagrange multipliers (equation~\ref{lagrangeEquation})\\\cline{4-4}
            &&&$\mbox{\textit{separating}} = \mbox{contact constraints with a component } \lambda_i < 0$&
            \curly{\ref{restingContact}}{\spx\spx\spx\spx\spx\spx\spx}\\\cline{4-4}
            &&&$\mbox{\textit{constraints}} = \mbox{\textit{constraints}} \;\backslash\;
            \mbox{\textit{separating}}$\\\cline{4-4}
        &&\multicolumn{2}{|l|}{Until $\mbox{\textit{separating}} = \{\}$}\\\cline{3-4}
        &&\multicolumn{2}{|l|}{Apply constraint forces $\m{J}^T\ve{\lambda}$ to bodies}\\\cline{3-4}
        &&\multicolumn{2}{|l|}{Compute derivative of state vector}&
        \curly{\ref{rigidBodyDynamics}}{\spx}\\\cline{2-4}
    &\multicolumn{3}{|l|}{Compute $O(h^4)$ and $O(h^5)$ approximations of new state vector}\\\cline{2-4}
    &\multicolumn{3}{|l|}{$\mbox{\textit{error}} = \mbox{difference between the approximations}$}\\\cline{2-4}
    &\multicolumn{3}{|l|}{If \textit{error} too large:}\\\cline{3-4}
        &&\multicolumn{2}{|l|}{Estimate new (smaller) value for $h$}&
        \curly{\ref{solvingODEs}}{\spx\spx\spx\spx\spx\spx\spx}\\\cline{3-4}
        &&\multicolumn{2}{|l|}{Goto \texttt{Time step}}\\\cline{2-4}
    &\multicolumn{3}{|l|}{Otherwise if error is small:}\\\cline{3-4}
        &&\multicolumn{2}{|l|}{Estimate new (larger) value for $h$, applicable in the next time step}\\\cline{2-4}
    &\multicolumn{3}{|l|}{Compute interactions (e.g.\ collisions) in new state}&
    \curly{\ref{meshIntersection}}{\spx}\\\cline{2-4}
    &\multicolumn{3}{|l|}{If penetration has occurred:}\\\cline{3-4}
        &&\multicolumn{2}{|l|}{Estimate new (smaller) value for $h$ by Newton-Raphson method}&
        \curly{\ref{findingContactTime}}{\spx\spx\spx}\\\cline{3-4}
        &&\multicolumn{2}{|l|}{Goto \texttt{Time step}}\\\cline{2-4}
    &\multicolumn{3}{|l|}{While there are colliding contacts:}\\\cline{3-4}
        &&\multicolumn{2}{|l|}{$\mbox{\textit{constraints}} = \mbox{\textit{equality constraints}}
        \cup \mbox{\textit{colliding contacts}}$}\\\cline{3-4}
        &&\multicolumn{2}{|l|}{Solve \textit{constraints} for Lagrange multipliers
        (equation~\ref{collisionLagrange})}&
        \curly{\ref{collidingContact}}{\spx\spx\spx\spx\spx}\\\cline{3-4}
        &&\multicolumn{2}{|l|}{Apply constraint impulses $\m{J}^T\ve{\lambda}$ to bodies}\\\cline{3-4}
        &&\multicolumn{2}{|l|}{Reclassify contact types according to new velocities}\\\cline{2-4}
    &\multicolumn{3}{|l|}{$\mbox{\textit{time}} = \mbox{\textit{time}} + h$}\\\cline{2-4}
    &\multicolumn{3}{|l|}{Output the simulation state for the current time}\\\cline{2-4}
\multicolumn{4}{|l|}{Until a predefined simulation time has been reached}\\\cline{1-4}
\end{tabular}
\caption{Overall (slightly simplified) structure of the simulation algorithm.\label{flowchart}}
\end{figure}

There was only one major design mistake which I had to correct during the debugging phase: I had
originally decided to store the current state of the simulation as values in each
\textsf{RigidBody} object. This caused errors when the simulation had to backtrack and retry a
step, because part of the body state had already been overwritten by the aborted step and could
not be regained without introducing tight coupling with the ODE solver. I changed the architecture
such that all time-varying state of a body is kept in a separate, immutable state vector, and all
operations require the current state as an argument, returning a new state. These side-effect-free
semantics made juggling different simulation states very much easier, but the rewriting necessary
to incorporate this architecture change took almost a week~-- it would have been no extra effort
if it had been planned in from the beginning.

I did not invest much effort in improving the run-time performance, but I did perform some
profiling which showed that a very large proportion of the time was being spent in the biconjugate
gradient solver for linear equations. I had originally implemented the \emph{preconditioned}
version of this algorithm described in~\cite{NRinC}, but noticed in the profiler that computing
the preconditioner matrix was more expensive than its benefit. Removing the preconditioning
immediately increased the execution speed of the whole simulation by a factor of 18.


\subsection{Extensions}

Being significantly behind schedule towards the end of the project, I decided not to add many
optional features~-- I merely wrote a short but exceedingly useful script to import completed
simulations into \textsl{Blender}, in order to create raytraced video files.

It is, however, fair to say that I vastly extended the project by solving a more general problem
than required, and solving it to a higher accuracy than required. I could have comparatively
easily implemented a penalty method simulation (see section~\ref{approachesToConstraints}) and
experimented with the spring constants until it just about worked. However, the Lagrange
multiplier approach I chose is much more reliable, more exact and more interesting and satisfying,
so I am happy to have taken this path despite the greater effort.
