\section{Collision and contact}

We now have all the mathematical facilities we need to simulate mechanical systems in which
the acceleration functions are continuous over time. This already covers a large number of
interesting systems, but unfortunately excludes any sort of collision between bodies. If we want
to examine systems of separable but non-penetrating bodies, we have to open a whole new can of
worms.

Let us distinguish two cases of contact between bodies: resting contact and colliding contact.
A book lying on your desk is in resting contact with the surface: their relative velocity is zero,
but the desk excerts a force on the book to prevent it from penetrating into the surface.
Colliding contact is given for example between the ground and a ball bouncing off it. In real
life, the ball stays in contact with the ground for a finite length of time, during which it is
deformed and experiences a finite force accelerating it upwards. In our simulation, however, we
are working with rigid bodies which cannot be deformed, so we want the collision to happen
instantaneously in the moment when the ball touches the ground. One way of looking at this is as
an infinitely strong force acting over an infinitely short time, but a more useful representation
is in terms of an impulse exchanged between the bodies.

Creating a simulation involving contacts is generally seen as a difficult task.
Baraff~\cite{BaraffWitkin:97} derives equations to handle collisions, and outlines (with a number
of errors) a way of handling resting contact. Unfortunately his collision handling does not work
in combination with constraints~-- it violates the assumption that the constraint function is
twice differentiable~-- and his resting contact computation relies on a complicated and uncommon
numerical routine. In this project, a new method of handling contacts is developed, which is
simpler to implement, more powerful, and works perfectly together with constraints like those
described in section~\ref{constraints}.

In the rest of this section we will examine the simulation only at one point in time, at which
the bodies in question are in contact. We also assume that we know the place at which the contact
occurs. Algorithms for finding both the time and place of contact are discussed elsewhere in this
report.

\subsection{Resting contact}

To keep things manageable, let us assume that we are dealing only with polyhedral bodies~-- bodies
whose exterior consists of flat polygon faces, delimited by vertices, joined by straight edges.
Since we will actually be working with a triangle mesh, this is fine.

There are two main ways in which polyhedra can be in contact: either by a vertex of one body being
inside a face of the other body, or by an edge of one body intersecting an edge of the other.
There remain a few corner cases, but we will think about those later. The book lying on your desk
may for example have four vertex/face contacts, each of the four corners of its back cover
touching the face of the desk surface. You may visualize edge/edge contacts by holding the book
such that its spine is touching the front edge of your desk.

In both cases, for the bodies not to interpenetrate, they must excert equal and opposite forces on
each other. This force must exactly balance the outside force, otherwise they would accelerate
apart. Also in both cases the direction of the force is perpendicular to the plane of contact. In
the vertex/face case, this plane is just the plane of the face polygon. In the edge/edge case, the
plane goes through the point of contact and is spanned by the directions of the two edges involved.
Modulo its sign, this plane's unit normal vector is unique~-- except if the two edges are
parallel, which is a case we will ignore for now.

Note that we are not trying to simulate friction at this point. The force in the direction of the
contact plane normal merely stops interpenetration~-- if you were to push the book over the
horizontal table surface, it would glide along without slowing down. We also class such gliding
behaviour as resting contact if the relative velocity of the bodies is parallel to the contact
plane.

How do we now compute this contact force in an arbitrary system, where there may be objects stacked
on top of each other, different forces and torques acting, and so on? Like in
section~\ref{constraints}, we can employ a constraint function. For a vertex/face contact, let the
value of this function \ve{c} be the distance of the vertex point from the plane, being negative on
one side and positive on the other; for an edge/edge contact, the value is the distance between the
two straight lines. Of course, when we are in contact, the distance is zero in both cases. When we
are in resting contact we also have $\dot{\ve{c}} = \ve{0}$, because the bodies are not moving
relative to each other along the plane's normal~-- though they may be moving perpendicular to it,
like in the case of the sliding book. The function becomes interesting when we consider its second
derivative, $\ddot{\ve{c}}$. If positive values of \ve{c} represent legal states (in which the
bodies are touching or separate), we can enforce the nonpenetration constraint by satisfying
\begin{equation} \label{constrInequality}
\ddot{\ve{c}} \ge \ve{0}.
\end{equation}

More exactly, if it is the case that $\ddot{\ve{c}} < \ve{0}$, we need to apply forces and torques
to the bodies such that in total we have $\ddot{\ve{c}} = \ve{0}$. But when
$\ddot{\ve{c}} \ge \ve{0}$, no force is applied (otherwise we would be glueing the book to the
table). But how do we solve this inequality in practise? At this point we diverge from Baraff's
method~\cite{BaraffWitkin:97}, who expresses equation~\ref{constrInequality} and additional
side-conditions as a ``quadratic program'' and uses a specialised numerical solver.

Let us take a much simpler approach and pretend for now that equation~\ref{constrInequality}
contained an equals sign. Then this is a constraint like any other, which we can satisfy by using
the Lagrange multiplier method of section~\ref{constraints}. Moreover, if there are multiple
points of resting contact in the system, and also `real' constraints like joints between bodies,
we can solve all of these simultaneously without thinking twice.

So that the function \ve{c} can be used in the Lagrange multiplier method, we need to derive the
Jacobian matrices \m{J} and $\dot{\m{J}}$ as we did for joints. This is easy to do for a
vertex/face contact, as shown in appendix~\ref{vertexFaceConstraint}, and harder but perfectly
possible for the edge/edge case (appendix~\ref{edgeEdgeConstraint}).

However, having solved equation~\ref{lagrangeEquation} for \ve{\lambda}, we need to take care.
Remember that each component of \ve{\lambda} specifies the `amount' of one particular constraint
that should be applied to the system. If you examine the formulae in
appendices~\ref{vertexFaceConstraint} and \ref{edgeEdgeConstraint}, you will notice that the
product $\m{J}^T\ve{\lambda}$ can be directly interpreted as scaling a unit amount of forces and
torques by a scalar~-- the scalar being the component of \ve{\lambda} corresponding to this
constraint. Hence we can deduce that a positive value of the $\ve{\lambda}$ component generates
forces and torques which push the bodies apart, while a negative value pulls them together (or
vice versa, whichever sign convention is used). It is such a negative $\ve{\lambda}$ component
that we must avoid.

This gives us a basis for an algorithm which turns equation~\ref{constrInequality} back into what
it actually is~-- an inequality: set up constraint functions for all contact points, and solve the
system of linear equations for the Lagrange multiplier \ve{\lambda}. In this vector, find all
components relating to contact constraints whose value is negative. (`Real' constraints which are
not points of resting contact are left untouched whatever their \ve{\lambda} component value is.)
If there are none, calculate $\m{J}^T\ve{\lambda}$ and add the forces and torques to the system~--
then we are done. If there aare negative components, completely discard the constraints to which
they belong (since the bodies are accelerating away from each other in this point, the contact
will break in the next time step), then repeat the solving for \ve{\lambda} with the reduced set
of constraints. The process may take several iterations before terminating, but always terminates
because in each iteration we either reduce the number of active constraints or exit.

I have not yet been successful in proving this algorithm correct, but despite extensive pondering
I have not found any examples in which it fails either.

\subsection{Colliding contact}

A similar method using Lagrange multipliers can be formulated to handle colliding contact. As in
the previous section, we can write down constraint functions \ve{c} for all points of contact.
While points of resting contact had the property that $\dot{\ve{c}} = 0$, colliding contact is
characterised by $\dot{\ve{c}} < 0$. (If $\dot{\ve{c}} > 0$ then the bodies are moving away from
each other. Such a contact can be ignored for now, but we cannot fully discard it, as explained
below.) Having a contact also implies $\ve{c} = 0$, so we need to immediately modify the bodies'
linear and angular momenta to satisfy $\ve{c}' \ge 0$, otherwise the bodies will interpenetrate
in the next time step.

This operation is completely different from applying forces or torques to the bodies, as these
change the momenta gradually by acceleration, not instantaneously. Rather than looking at the
level of acceleration, which is the second derivative of state with respect to time, we now need
to think on the level of velocity, i.e.\ the first derivative.

Physically, this operation is expressed in terms of an \emph{impulse}. An impulse \ve{u} has the
same dimensions as linear momentum \ve{p} (kg\,m/s) and is directly added to the momentum of the
body to which it is applied: $\ve{p}' = \ve{p} + \ve{u}$. If the impulse is applied at the point
$\ve{s}$, and \ve{r} is the body's centre of mass, it also changes the angular momentum to
$\ve{L}' = \ve{L} + (\ve{s} - \ve{r})\times\ve{u}$. This behaviour is analogous to that of a
force.

A collision between two rigid bodies must conserve the total momentum of the system. This implies
that the impulses acting on the bodies at a point of collision must be equal and opposite. However,
the collision need not necessarily conserve energy. A collision which \emph{does} conserve energy
is called \emph{elastic} or \emph{fully elastic}, and may be given for example by an ideal rubber
ball which, when dropped, bounces up to exactly the same height as it was dropped from. At the
other extreme, an \emph{inelastic} collision is one which reduces the energy of the system as much
as possible~-- this energy difference is dissipated as heat. We cannot say that an inelastic
collision reduces the energy to zero, since the absolute energy depends on the frame of reference.
In an inelastic collision, bodies generally do not `bounce apart' again.

Most collisions in real life are somewhere in between, depending on the materials of the colliding
objects. Let us express this behaviour using a single `bounciness' scalar
$0 \le \varepsilon \le 1$, where $\varepsilon = 0$ indicates an inelastic collision, and
$\varepsilon = 1$ full elasticity\footnote{Values of $\varepsilon > 1$ are reserved for Science
Fiction films.}.

How do we now find the impulses we need to apply to the colliding bodies, and how do we
simultaneously handle constraints? As previously for resting contact we can use a Lagrange
multiplier method. The constraint function \ve{c} must be set up to include all `real' constraints
and all points of colliding contact. Points of resting contact or separating contacts must
\emph{not} be included. Now for all points $i$ of colliding contact we have $\dot{\ve{c}}_i < 0$.
Remember that this value is equal to (or at least proportional to) the relative velocity of the
bodies in the point of contact. From conservation of momentum we can prove that for such a point,
the relative velocity $\dot{\ve{c}}_i'$ after the collision is given by
$\dot{\ve{c}}_i' = -\varepsilon_i \dot{\ve{c}}_i$.

Assume for convenience that the first $m$ components of \ve{c} represent `real' constraints, and
that the remaining $k$ components are due to colliding contacts. We can now formulate a condition
which requires all `real' constraints to be satisfied after the collision, and also requires each
collision to have performed the correct amount of elastic `bounce'. $\dot{\ve{c}}'$ is the
required value of $\dot{\ve{c}}$ after the collision:
\begin{equation}
\dot{\ve{c}}' = \left[\begin{array}[m]{c}
    \left. \begin{array}{c} 0 \\\vdots\\ 0 \end{array} \right\} m \\
    -\varepsilon_1 \dot{\ve{c}}_{m+1} \\\vdots\\
    -\varepsilon_k \dot{\ve{c}}_{m+k}
    \end{array}\right]
\end{equation}

We can rewrite this as $\dot{\ve{c}}' = \dot{\ve{c}} - \m{E}\dot{\ve{c}}$, where \m{E} is the
diagonal $m+k \times m+k$ matrix
\begin{equation}
\m{E} = \left[ \begin{array}{cc}
    \begin{array}{ccc} 1 \\ & \ddots \\ && 1 \end{array} \\
    \underbrace{\quad\quad\quad\quad}_m &
    \begin{array}[t]{ccc} 1+\varepsilon_1 \\ & \ddots \\ && 1+\varepsilon_k \end{array}
    \end{array} \right]
\end{equation}

Let us now concatenate the linear and angular momenta of all $n$ bodies into a single vector
\ve{\Psi}, like we previously did for forces and torques (equation~\ref{PhiVector}):
\begin{equation} \label{PsiVector}
\ve{\Psi} = \left[\begin{array}{c}
    \ve{p}_1 \\ \ve{L}_1 \\ \vdots \\ \ve{p}_n \\ \ve{L}_n \end{array}\right]
\end{equation}

From the definition of $\m{M}^{-1}$ (equation~\ref{massInertiaTensor}) we can deduce that
$\dot{\ve{x}} = \m{M}^{-1}\ve{\Psi}$. What we require now is a vector $\ve{\Psi}_c$ which, when
added to $\ve{\Psi}$, causes the constraints to be satisfied:
\begin{equation}
\dot{\ve{c}} = \m{J}\dot{\ve{x}} = \m{J}\m{M}^{-1}\ve{\Psi} \quad\Longrightarrow\quad
    \dot{\ve{c}}' = \m{J}\m{M}^{-1}(\ve{\Psi} + \ve{\Psi}_c)
\end{equation}
(cf.\ equation~\ref{cDotAndCDDot}).
It turns out\footnote{The argument is analogous to the derivation of the force vector in terms of
Lagrange multipliers; see~\cite{BaraffWitkin:97} for details.} that this vector can be written as
$\m{J}^T\ve{\lambda}$ for some $m+k$-row vector \ve{\lambda}. Hence we obtain
\begin{eqnarray}
\dot{\ve{c}}' &=& \m{J}\m{M}^{-1}(\ve{\Psi} + \m{J}^T\ve{\lambda}) \nonumber\\
\dot{\ve{c}} - \m{E}\dot{\ve{c}} &=&
    \m{J}\m{M}^{-1}\ve{\Psi} + \m{J}\m{M}^{-1}\m{J}^T\ve{\lambda} \nonumber\\
\m{J}\m{M}^{-1}\ve{\Psi} - \m{E}\m{J}\m{M}^{-1}\ve{\Psi} & = &
    \m{J}\m{M}^{-1}\ve{\Psi} + \m{J}\m{M}^{-1}\m{J}^T\ve{\lambda} \nonumber\\
-\m{J}\m{M}^{-1}\m{J}^T\ve{\lambda} &=& \m{E}\m{J}\m{M}^{-1}\ve{\Psi} \label{collisionLagrange}
\end{eqnarray}

Equation~\ref{collisionLagrange} is just a system of linear equations which we can solve for
\ve{\lambda}. The resulting vector $\ve{\Psi}_c = \m{J}^T\ve{\lambda}$ of impulses can be
directly added to the rigid bodies' momenta.

We are not quite done yet. Having modified the bodies' momenta, the state of other contact points
in the system may have changed. While the previously colliding contacts will have
turned into resting or separating contacts, other (previously unconsidered) contacts may now
be colliding! Thus we must repeat the whole process described in this section, ignoring the
previous colliding points, and considering the new ones instead. If there are no new colliding
contacts, we have finished.

The bad news is that this algorithm is not guaranteed to terminate~-- indeed we can come up with
situations in which it will run indefinitely. An easy way of solving this problem is by not
allowing $\varepsilon$ to be too close to 1; then if a loop occurs, the system will eventually
run out of energy and return to a resting contact.


\subsection{Generalised collisions}

-- to be written --
