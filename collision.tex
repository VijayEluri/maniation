\section{Collision and contact}

We now have all the mathematical facilities we need to simulate mechanical systems in which
the acceleration functions are continuous over time. This already covers a large number of
interesting systems, but unfortunately excludes any sort of collision between bodies. If we want
to examine systems of separable but non-penetrating bodies, we have to open a whole new can of
worms.

Let us distinguish two cases of contact between bodies: resting contact and colliding contact.
A book lying on your desk is in resting contact with the surface: their relative velocity is zero,
but the desk excerts a force on the book to prevent it from penetrating into the surface.
Colliding contact is given for example between the ground and a ball bouncing off it. In real
life, the ball stays in contact with the ground for a finite length of time, during which it is
deformed and experiences a finite force accelerating it upwards. In our simulation, however, we
are working with rigid bodies which cannot be deformed, so we want the collision to happen
instantaneously in the moment when the ball touches the ground. One way of looking at this is as
an infinitely strong force acting over an infinitely short time, but a more useful representation
is in terms of an impulse exchanged between the bodies.

Creating a simulation involving contacts is generally seen as a difficult task.
Baraff~\cite{BaraffWitkin:97} derives equations to handle collisions, and outlines (with a number
of errors) a way of handling resting contact. Unfortunately his collision handling does not work
in combination with constraints~-- it violates the assumption that the constraint function is
twice differentiable~-- and his resting contact computation relies on a complicated and uncommon
numerical routine. In this project, a new method of handling contacts is developed, which is
simpler to implement, more powerful, and works perfectly together with constraints like those
described in section~\ref{constraints}.

In the rest of this section we will examine the simulation only at one point in time, at which
the bodies in question are in contact. We also assume that we know the place at which the contact
occurs. Algorithms for finding both the time and place of contact are discussed elsewhere in this
report.

\subsection{Resting contact}

To keep things manageable, let us assume that we are dealing only with polyhedral bodies~-- bodies
whose exterior consists of flat polygon faces, delimited by vertices, joined by straight edges.
Since we will actually be working with a triangle mesh, this is fine.

There are two main ways in which polyhedra can be in contact: either by a vertex of one body being
inside a face of the other body, or by an edge of one body intersecting an edge of the other.
There remain a few corner cases, but we will think about those later. The book lying on your desk
may for example have four vertex/face contacts, each of the four corners of its back cover
touching the face of the desk surface. You may visualize edge/edge contacts by holding the book
such that its spine is touching the front edge of your desk.

In both cases, for the bodies not to interpenetrate, they must excert equal and opposite forces on
each other. This force must exactly balance the outside force, otherwise they would accelerate
apart. Also in both cases the direction of the force is perpendicular to the plane of contact. In
the vertex/face case, this plane is just the plane of the face polygon. In the edge/edge case, the
plane goes through the point of contact and is spanned by the directions of the two edges involved.
Modulo its sign, this plane's unit normal vector is unique~-- except if the two edges are
parallel, which is a case we will ignore for now.

Note that we are not trying to simulate friction at this point. The force in the direction of the
contact plane normal merely stops interpenetration~-- if you were to push the book over the
horizontal table surface, it would glide along without slowing down.

How do we now compute this contact force in an arbitrary system, where there may be objects stacked
on top of each other, different forces and torques acting, and so on? Like in
section~\ref{constraints}, we can employ a constraint function. For a vertex/face contact, let the
value of this function \ve{c} be the distance of the vertex point from the plane, being negative on
one side and positive on the other; for an edge/edge contact, the value is the distance between the
two straight lines. Of course, when we are in contact, the distance is zero in both cases. When we
are in resting contact we also have $\dot{\ve{c}} = \ve{0}$, because the bodies are not moving
relative to each other along the plane's normal~-- though they may be moving perpendicular to it,
like in the case of the sliding book. The function becomes interesting when we consider its second
derivative, $\ddot{\ve{c}}$. If positive values of \ve{c} represent legal states (in which the
bodies are touching or separate), we can enforce the nonpenetration constraint by satisfying
\begin{equation} \label{constrInequality}
\ddot{\ve{c}} \ge \ve{0}.
\end{equation}

More exactly, if it is the case that $\ddot{\ve{c}} < \ve{0}$, we need to apply forces and torques
to the bodies such that in total we have $\ddot{\ve{c}} = \ve{0}$. But when
$\ddot{\ve{c}} \ge \ve{0}$, no force is applied (otherwise we would be glueing the book to the
table). But how do we solve this inequality in practise? At this point we diverge from Baraff's
method~\cite{BaraffWitkin:97}, who expresses equation~\ref{constrInequality} and additional
side-conditions as a ``quadratic program'' and uses a specialised numerical solver.

Let us take a much simpler approach and pretend for now that equation~\ref{constrInequality}
contained an equals sign. Then this is a constraint like any other, which we can satisfy by using
the Lagrange multiplier method of section~\ref{constraints}. Moreover, if there are multiple
points of resting contact in the system, and also `real' constraints like joints between bodies,
we can solve all of these simultaneously without thinking twice.

So that the function \ve{c} can be used in the Lagrange multiplier method, we need to derive the
Jacobian matrices \m{J} and $\dot{\m{J}}$ as we did for joints. This is easy to do for a
vertex/face contact, as shown in appendix~\ref{vertexFaceConstraint}, and harder but perfectly
possible for the edge/edge case (appendix~\ref{edgeEdgeConstraint}).

However, having solved equation~\ref{lagrangeEquation} for \ve{\lambda}, we need to take care.
Remember that each component of \ve{\lambda} specifies the `amount' of one particular constraint
that should be applied to the system. If you examine the formulae in
appendices~\ref{vertexFaceConstraint} and \ref{edgeEdgeConstraint}, you will notice that the
product $\m{J}^T\ve{\lambda}$ can be directly interpreted as scaling a unit amount of forces and
torques by a scalar~-- the scalar being the component of \ve{\lambda} corresponding to this
constraint. Hence we can deduce that a positive value of the $\ve{\lambda}$ component generates
forces and torques which push the bodies apart, while a negative value pulls them together (or
vice versa, whichever sign convention is used). It is such a negative $\ve{\lambda}$ component
that we must avoid.

This gives us a basis for an algorithm which turns equation~\ref{constrInequality} back into what
it actually is~-- an inequality: set up constraint functions for all contact points, and solve the
system of linear equations for the Lagrange multiplier \ve{\lambda}. In this vector, find all
components relating to contact constraints whose value is negative. (`Real' constraints are left
untouched whatever their \ve{\lambda} component value is.) If there are none, calculate
$\m{J}^T\ve{\lambda}$ and add the forces and torques to the system~-- then we are done. If there
are negative components, completely discard the constraints to which they belong (since the bodies
are accelerating away from each other in this point, the contact will break in the next time step),
then repeat the solving for \ve{\lambda} with the reduced set of constraints. The process may take
several iterations before terminating.

I have not yet been successful in proving this algorithm correct, but despite extensive pondering
I have not found any examples in which it fails either.

\subsection{Colliding contact}


